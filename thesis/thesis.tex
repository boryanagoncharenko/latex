\documentclass[parskip=full]{uvamscse}

\setcounter{secnumdepth}{4}

\titleformat{\paragraph}
{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titlespacing*{\paragraph}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

\input{program-listings}
\newcommand{\cmd}[1]{\texttt{$\backslash$#1}}

\title{Detecting Violations of CSS Code Conventions}
% \coverpic[100pt]{figures/terminal.png}
% \subtitle{}
% \date{Spring 2014}


\author{Boryana Goncharenko}
\authemail{boryana.goncharenko@gmail.com}
% \host{Grammarware, Inc., \url{http://grammarware.github.io}}

\abstract{    

Code conventions are used to preserve code base consistency and express preference of a particular
programming style. Often, code conventions are expressed in natural language and it is a
responsibility of the developers to read, understand and apply them. Typically, developers need to
ensure that their code complies to a given style guide manually. There are a number of tools that
can automatically detect violations of conventions, however, current solutions remain rigid,
laborious or with limited scope.

This thesis aims at answering three research questions. First, it evaluates the need for CSS
conventions based on whether CSS is still handcrafted. Second, it discovers existing code
conventions. Third, it designs a domain-specific language that is capable of expressing existing CSS
code conventions. The thesis presents a specification of the designed domain-specific language and an implementation of its interpreter that detects violations automatically.

}


\begin{document}
\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}

Code conventions put constraints on how code should be written in the context of a project,
organization or programming language. Style guides can comprise conventions that refer to
whitespacing, indentation, code layout, preference of syntactic structures, code patterns and anti-
patterns. They are mainly used to achieve code consistency, which in turn improves the readability,
understandability and maintainability of the code [Citations].

Style guides are often designed in an ad hoc manner. Coding conventions typically live in documents
that contain a description of each rule in natural language accompanied by code examples. This is
the case with the style guidelines of Mozilla [8], Google [6], GitHub [10], WordPress [11] and
Drupal [4]. To apply the conventions, developers first need to read, understand and apply them
manually. Such an approach introduces a number of issues. Using natural language can make guidelines
incorrect, ambiguous, implicit or too general. Another problem is that developers apply conventions
manually, which increases the chances of introducing violations involuntarily. There are tools that
check for compliance with guidelines, however, they are often hard to customize or limited to one
type of violations, e.g. only whitespacing.

The core idea behind the project is to provide a solution that lets developers express an arbitrary
set of coding conventions and detect their violations automatically in an IDE. Writing conventions
in an executable form could assist authors in detecting incorrect, ambiguous or inconsistent
guidelines. Automatic detection of violations could minimize the effort required by developers to
write code that complies to the guidelines. To meet the constraints of a Master’s project, the
implementation is limited to the domain of Cascading Style Sheets (CSS). The project requires
determining the need for CSS code conventions in organizations, collecting and analyzing available
style guides, and providing a way to express conventions. Specifically, the project attempts to
answer the following set of questions:

  \begin{description}
    \item \textbf{Research Question 1:} Do developers still maintain plain CSS?
    \item \textbf{Research Question 2:} What code conventions for CSS exist?
    \item \textbf{Research Question 3:} How to express existing CSS code conventions?
  \end{description}

The thesis is organized as follows. Chapter 2 provides information about previous studies and
defines terms used throughout the thesis. Chapter 3 presents the research approach used to determine
whether CSS is handcrafted. The process and results of discovering the existing code conventions is
described in Chapter 4. The design and description of a DSL is presented in Chapter 5. Chapter 6
concludes the thesis.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Background}

\section{Bunge-Wand-Weber ontology}

A \textbf{conceptualization} is an abstract, simplified view of the world that is represented for
some purpose~\cite{gruber1995toward}. It consists of the concepts that are assumed to exist in some
area of interest and their relationships~\cite{gruber1995toward}. An \textbf{ontology} is an
explicit specification of a conceptualization~\cite{gruber1995toward}. It describes what is
fundamental in the totality of what exists and it defines the most general categories to which we
need to refer in constructing a description of reality~\cite{milton2004top}.

Milton further distinguishes between two kinds of ontologies: top-level and domain-
specific~\cite{milton2004top}. Ontologies of the former type are highly general and provide the
theoretical foundations for representation and modeling of systems. Ontologies of the latter type
are restricted to define concepts and their relations that fall in a particular domain. Every
domain-specific ontology needs to use categories that are captured in a top-level ontology. In this
sense a domain-specific ontology is based on a specific top-level ontology~\cite{milton2004top}.

The Bunge-Wand-Weber (BWW) ontology~\cite{wand1990ontological} is a high-level ontology used in the representation model developed by Wand and Weber~\cite{wand1995deep}. Table 2.1 presents a selected set of the ontological constructs in the BWW ontology.

\begin{center}
\begin{longtable}{ | p{11em} | p{30em} | } 
\caption{Selected ontological constructs in the BWW representation model}\\
\hline
 &  \\
\textbf{Ontological construct} & \textbf{Explanation} \\
 &  \\
\hline
Thing & The elementary unit in the BWW ontological model. The real world is made up of things. A composite thing may be made up of other things (composite or primitive). \\ 
\hline
Properties & \multirow{7}{30em}{Things possess properties. A property is modeled via a function that maps the thing into some value. A property of a composite thing that belongs to a component thing is called an hereditary property. Otherwise it is called an emergent property. A property that is inherently a property of an individual thing is called an intrinsic property. A property that is meaningful only in the context of two or mode things is called a mutual or relational property.} \\ 
 &  \\ 
 &  \\
 &  \\
 &  \\
 &  \\
 &  \\
 \hline
 State & A vector of values for all property functions of a thing. \\
 \hline
 Event & A change of state of a thing. It is effected via a transformation. \\
 \hline
 Transformation & A mapping from a domain comprising states to a codomain comprising states. \\
 \hline
 History & The chronologically ordered states that a thing traverses. \\
 \hline
 Coupling & A thing acts on another thing if its existence affects the history of the other thing. The two things are said to be coupled or interact. \\
 \hline
 Class & A class is a set of things that can be defined via their possessing a characteristic property. \\ 
 \hline
 Kind & A kind is a set of things that can be defined only via their possessing two or more properties. \\ 
\hline
 System & A set of things is a system if, for any bi-partitioning of the set, couplings exist among things in the two subsets. \\
 \hline
 System Composition & The things in the system are its composition. \\
 \hline
 System Environment &  Things that are not in the system but interact with things in the system are called the environment of the system. \\
 \hline
\end{longtable}
\end{center}


\section{Ontological analysis}

\textbf{Ontological analysis} is an established approach for evaluating the quality of software engineering notations~\cite{moody2009physics}. It consists of a two way comparison between a set of modeling grammar constructs and a set of ontological constructs. The \textbf{interpretation mapping} compares the notation with the ontology and the \textbf{representation mapping} compares the ontology with the notation~\cite{gehlert2007toward}. The underpinning of ontological analysis is that modeling grammars are incomplete if they are not able to represent what exists in reality~\cite{green2000integrated}. Furthermore, the analysis requires one-to-one mapping between the modeling grammar and the ontological constructs. Any deviation from such correspondence leads to an anomaly (Figure 2.1).

\begin{figure}[h!]
  \centering
  \caption{Ontological Analysis~\cite{gehlert2007toward}}
  \includegraphics[width=0.65\textwidth]{ontoanalysis}
\end{figure}

\textbf{Construct deficit} occurs when an ontological construct does not have a corresponding construct in the modeling grammar. \textbf{Construct redundancy} is observed when a single ontological construct maps to more than one modeling grammar construct. \textbf{Construct overload} appears when a modeling grammar construct corresponds to more than one ontological construct. \textbf{Construct excess} occurs when a modeling grammar construct does not map to any ontological construct.~\cite{moody2009physics}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Evaluating the Need for CSS Code Conventions}

\section{Research Method}

Despite the new features added in the second~\cite{CSS2} and third~\cite{CSS3} versions of CSS, the
language has obvious limitations, for example, lack of variables. A number of preprocessors have
evolved to tackle the downsides of CSS. Solutions such as SASS~\cite{SASS}, LESS~\cite{LESS} and
Stylus~\cite{Stylus} offer enhanced or even different syntax and translate it to CSS. Preprocessors
are not only ubiquitously recommended, but also widely adopted in practice. The presence of such
solutions poses the question whether conventions for CSS are required at all. If nowadays CSS is
generated and not handcrafted, there is not need for conventions for CSS. There is need for
conventions for the preprocessor languages.

To determine whether CSS is still handcrafted, all commits to open source repositories hosted on
GitHub for the period Jan-Apr 2015 have been analyzed. To differentiate between plain CSS and
preprocessor code, the extensions of all files in the commits were inspected. In case the commit
contains a file with extension \texttt{.scss}, \texttt{.sass}, \texttt{.less} or \texttt{.styl}, it
is considered preprocessor maintenance. In case the commit contains files with the \texttt{.css}
extension and no preprocessor extensions, it is considered maintenance of plain CSS. Since the main
objective of the search is to determine maintenance, only files that were modified are taken into
consideration. Files that were added are excluded from the results, since developers often add
third-party CSS libraries to their repositories.


\section{Results}

A total of 1,589,713 commits to 1,311,654 public repositories have been analyzed. X of these were not processed due to errors. Typical errors contain repositories that have been turned private and... The number of commits that maintain any form of CSS is X. Figure 1 summarizes the findings.

\begin{figure}[h!]
  \centering
  \caption{Results}
  \includegraphics[width=0.5\textwidth]{cssresults}
\end{figure}

\section{Analysis}

There are a number of limitations that need to be considered before interpreting the results of the
experiment. Firstly, the search is conducted on a single hosting platform - GitHub. That said, currently
GitHub reports having over 10 million users and 24 million repositories~\cite{GitHub}, which makes
it the largest code host in the world~\cite{gousios2014lean}. Secondly, the search is narrowed to
the publicly available repositories. Thus, it lies on the premise that there is not a significant
difference between the public and private repositories hosted on the platform. Thirdly, the
experiment detects only the three most popular preprocessor extensions and omits other
preprocessors. It is possible that a number of custom preprocessors are used in practice. However,
it is assumed that the number of such commits would not increase the number of total CSS commits to
the extend at which the percentage of plain CSS commits is significantly diminished.

Having the above limitations in mind, the experiment provides evidence to conclude that despite the popularity of preprocessors, plain CSS is still handcrafted in the beginning of 2015.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Discovering Existing CSS Code Conventions}

\section{Research Method}

The primary organization responsible for the specification of CSS has not published an official CSS
style guide. As a result, the CSS community has produced a pool of coding conventions, best
practices, guidelines and recommendations.

To discover existing CSS code conventions, two searches with the keywords ``CSS code conventions''
have been made using the search engines \url{http://duckduckgo.com} and \url{http://google.com}. The
first 100 results of each search have been analyzed. From each result only conventions that refer to
plain CSS have been taken into account and conventions related to preprocessors have been ignored.
In case the result contains links to other style guides, these references have been considered as
results and analyzed separately.

During the process of discovering conventions, a number of issues have been observed. First, some of
the conventions did not provide sufficient information to be applied in practice. Such an example is
the convention ``don’t use CSS hacks — try a different approach first'' when the style guide does
not define the meaning of CSS hacks. Overgeneralized conventions have been omitted from the results.

Another part of the discovered conventions introduced a discrepancy between their description in
natural language and the provided code example. An instance of such contradiction is when the
convention ``nothing but declarations should be indented'' is followed by a code snippet
illustrating that rules in media queries should also be indented. In such cases the convention is
interpreted as described by the code example.

In some cases, when conventions are not supported with code examples, their description remains open
for interpretation. For example, ``rules with more than 4 selectors are not allowed'' could be seen
as forbidding multi-selectors with more than four selectors, or disallowing selectors with more than
four simple-selectors. All possible interpretations of ambiguous conventions were registered as
separate conventions.

There are conventions that are not explicitly stated, but could only be inferred by the other rules.
For example, the convention ``you can put long values on multiple lines'' implies that values
should appear on one line. Implicit conventions were registered as explicit conventions.

\section{Results}

As a result of the searches, a set of 165 unique CSS code conventions has been accumulated. Sources
of these conventions include CSS professionals, open-source communities and companies, such as \href{https://google-styleguide.googlecode.com/svn/trunk/htmlcssguide.xml#Protocol}{Google}, \href{http://primercss.io/guidelines/#css}{GitHub}, \href{https://make.wordpress.org/core/handbook/best-practices/coding-standards/css/}{Wordpress}, \href{https://www.drupal.org/node/1887862}{Drupal}. Following is a listing that contains a selected set of the discovered conventions:

\begin{itemize} 
\item Avoid qualifying ID and class names with type selectors. 
\item Use RGBA only when opacity is needed.
\item Use short hexadecimal values. 
\item CSS files must not include any @charset statements.
\item Disallow @import. 
\item When possible, use em instead of pix. 
\item Avoid using z-indexes when possible. 
\item Require compatible vendor prefixes. 
\item Do not use !important. 
\item Do not use id selectors. 
\item Id and class names should be lowercase.
\item All values except the contents of strings should be lowercase.  
\item HTML tags should be lowercase.
\item Put a ; at the end of declarations. 
\item Do not put quotes in URL declarations.
\item Use short hex values.
\item Use the shorthand margin property.
\item Do not use units after 0 values.
\item Use a leading zero for decimal values.
\item Use single quotes in charsets.
\item Use single quotes in attribute selectors.
\item Put one space between the colon and the value of a declaration.
\item Put one space between the last selector and the block.
\item One selector per line.
\item A rule must not contain height and border, border-top, border-bottom, padding, padding-top, or padding-bottom.
\item A rule must not contain width and border, border-left, border-right, padding, padding-left, or padding-right.
\item Warning if a property is included in a rule twice and contains the same value.
\item Forbid empty rules.
\item A vendor-prefixed property must be followed by a standard property.
\item Require fallback color. A color property with a RGBA(), HSL(), or HSLA() color without a preceding color property that has an older color format.
\item A rule that has display: inline-block should not use float.
\item A rule that has display: block should not use vertical-align.
\item Use 4 spaces for indentation, no tabs.
\item No trailing spaces.
\end{itemize}

The full list of all discovered conventions along with their sources and explanation of their meaning is available in the \href{https://github.com/boryanagoncharenko/CssCoco/blob/master/analysis.md}{CssCoco GitHub repository}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Expressing CSS Code Conventions}

\section{Analysis of conventions corpus}

Analysis of the discovered conventions have been conducted in three steps. First, conventions have
been separated in groups depending on the type of constraints they enforce. Second, the meaning and
possible violations of each convention have been analyzed. Third, a list of general requirements
have been extracted.

Code conventions is an umbrella term that refers to constraints on whitespacing, indentation, naming, syntax, code patterns, programming style, file organization etc. To gain an overview of the type of constraints imposed in CSS, all conventions in corpus have been analyzed and organized in the following set of categories:

\begin{description}
  \item[Layout] category contains rules that constrain the overall layout of the code. It includes conventions related to whitespace, indentation and comments. Examples include:
  \begin{itemize}
  \item Use four tabs for indentation.
  \item Put one blank line between rulesets.
  \item Disallow spaces at the end of the line.
  \end{itemize}
  \item[Syntax Preference] category comprises conventions that express preference of a particular syntax. Note that rules in this category do not aim at ensuring CSS validity, but choose between syntactic alternatives. For example, both single and double quote strings are valid in CSS and a convention may narrow down the choice of the developer to single quotes. Examples include:
  \begin{itemize}
  \item Use lowercase for id and class names.
  \item Require a semicolon at the end of the last declaration.
  \item Use strings with single quotes.
  \end{itemize}
  \item[Programming Style] category consists of conventions that put constraints on how CSS constructs are used to achieve a certain goal. They express good and bad practices in the CSS domain and are used to improve maintenance and performance, or to avoid a bug in a particular implementation. Examples are:
  \begin{itemize}
  \item Do not use the universal selector.
  \item Avoid using !important.
  \item A vendor-prefixed property must be followed by a standard property.
  \end{itemize}
\end{description}

The second part of domain analysis consists of discussing the meaning of each convention and
determining the possible violations. While.. Further, the analysis determines how these violations
can be detected. Currently the detection of violations is performed by developers manually or
with the partial help of tools. To perform such checks, developers need to understand different concepts, e.g. the concept of a rule, HTML element, IDs, etc and perform certain actions, such as find a structure, evaluate a constraint etc. The analysis tries to grasp the specific concepts and actions used to find violations. 

The process of analysis is illustrate in the following example. Analysis of all conventions in the
corpus is available at \href{https://github.com/boryanagoncharenko/CssCoco/blob/master/analysis.md}{CssCoco GitHub repository}.

\textbf{Convention:} Disallow empty rules.
\textbf{Author:} CSS lint
\textbf{Violations:} Presence of rulesets that do not contain declarations. In case at least one declaration is present, the ruleset does not violate the convention. Examples include:
\begin{sourcecode}
\begin{lstlisting}[style=mono,language=Java]
.myclass { }                 /* violation */
.myclass { /* Comment */ }   /* violation */
.myclass { color: green; }   /* not violation */
\end{lstlisting}
\end{sourcecode}

\textbf{Actions:} Recognize rulesets and declarations. Determine whether a ruleset does not contain any declarations.

\textbf{Discussion:} the convention aims at getting rid of one type of refactoring leftovers -
rulesets without declarations [CSS lint]. Removing empty rulesets reduces the total size of CSS that
needs to be processed by the browser. One possible approach for discovering violations of the
convention at hand is to search the stylesheet for rulesets and then check whether each ruleset
contains a declaration. To perform this search successfully, developers need to understand the
concept of a ruleset and a declaration, i.e. they need to be able to recognize these two CSS
structures. Further, developers need to determine relations between structures, particularly,
whether a ruleset contains a declaration.

After all conventions have been analyzed, the specific actions and concepts were used to extract requirements. The following set of general requirements have been detected:

\begin{description}
  \item Every convention can be represented as a combination of constraints. There are two major constructs used to express conventions in natural language: forbid and require. Conventions that that forbid describe directly their violations. For example, the convention ``disallow @import'' specifies that import statements are violations. Conventions that use the latter construct describe a pattern and once the pattern is found the constraint is evaluated. If case the constraint is not met, a violation is discovered. For example, the convention ``class names should be lowercase'' requires finding class nodes and then evaluating whether they are lowercase. 

  \item As a direct consequence of the introduced categories of conventions Conventions can refer to nodes in abstract syntax tree, concrete syntax tree and parse tree of
CSS.
\end{description}
1) Every convention imposes a set of constraints over the program. Violations occur when these
constraints are not met.

2) 

3) Conventions can refer to nodes based on their type or function in the program (hex, color)

4) Conventions can refer to nodes based on CSS-specific knowledge, e.g. is vendor-specific property

4) Conventions can refer to nodes based on their context. Typically, conventions do not target a
node in isolation but a number of related nodes that form a pattern. The nodes do not have to be
immediately related, they could be scattered across the tree.

\section{Abstract syntax}

TODO: Types are still missing

This section describes the abstract syntax of CssCoco. An overview of the abstract syntax is shows in Figure x. A detailed view of each of the .. is presented afterwards.

\includegraphics[width=\textwidth]{general}

\begin{description}

\item\textbf{ConventionSet} represents a style guide. It comprises a number of conventions that form coherent guidelines. Attribute \texttt{contexts} is a list of Contexts that contain conventions.


\item\textbf{Context} represents a group of conventions that belong to the same semantic group (e.g. whitespacing, syntax preference, programming style). Attribute \texttt{conventions} is a list of Contexts that contain conventions. Attribute \texttt{ignored\_patterns} is a list of Patterns that are ignored while searching for the target pattern. For example, while searching for violations of semantic conventions, the whitespacing and indentation nodes are ignored.


\item\textbf{Convention} represents a rule that enforces specific constraints. Attribute \texttt{pattern} is the pattern that the convention targets. Attribute \texttt{description} is the description of the convention in natural text. This description is displayed to the user when a violation of the convention is discovered.


\item\textbf{Pattern} represents a description of a node or a combination of related nodes that given convention constraints.  Attribute \texttt{root} is the top node described in the pattern. Attribute \texttt{nodes} is a collection of all nodes described by the pattern. Attribute \texttt{relations} is a collection of relationships between the nodes used in the pattern.


\item\textbf{SequencePattern} represents a special type pattern in which nodes are allowed to be only siblings. Attribute \texttt{root} is the top node described in the pattern. Attribute \texttt{nodes} is a collection of all nodes described by the pattern. Attribute \texttt{relations} is a collection of relationships between the nodes used in the pattern.


\item\textbf{Node} represents a description of a non-whitespace node used in a Pattern.  
Attribute \texttt{descriptor} contains information about the type of the described node. Attribute \texttt{constraint} is an expression that designates additional constraints applied to the node. Attribute \texttt{identifier} is a given string that can be used as a reference to the matched node.


\item\textbf{WhitespaceNode} represents a description of a whitespace node that references space, newline, indentation symbols. Attribute \texttt{descriptor} contains information about the type of the described node. Attribute \texttt{repeater} is an optional constraint that specific the number of times a whitespace node can appear consecutively. Repeaters are useful to express conventions that do not specify exact quantities of whitespace symbols. For example, the convention ``put at least one blank line between rules'' sets a lower limit of the number of blank lines, but not an upper limit.


\item\textbf{WhitespaceVariation} represents a description of acceptable whitespace sequences. Whitespace variations are allowed to appear as operands of BeforeExpr, AfterExpr and BetweenExpr.  Attribute \texttt{descriptor} contains information about the type of the described node. Attribute \texttt{constraint} is an expression that designates additional constraints applied to the node. Attribute \texttt{identifier} is a given string that can be used as a reference to the matched node.


\item\textbf{NodeDescriptor} represents a description of the type of the Node. Conventions refer to nodes using their CSS type, their function in the CSS program or their concrete syntax representation. For example, the code ``\#E6E6E6'' can be addressed both as a hexadecimal value and as a color. Attribute \texttt{func} is a lambda function that determines whether a node meets the type constraint. This function is used to select match candidates while searching the CSS tree for violation patterns. In this way the additional constraints imposed by the Node are evaluated only for the candidates.


\item\textbf{NodeRelation} represents a relation between two Nodes. Specializations of node relation are previous sibling, next sibling, parent and ancestor relations. Attribute \texttt{target\_node} designates the Node targeted by the relation.

\includegraphics[width=\textwidth]{expr}

\item\textbf{LiteralExpr} represents an expression containing a literal value. Attribute \texttt{value} is the value of the literal expression.

\item\textbf{VariableExpr} represents a reference to a matched node. Attribute \texttt{name} is the identifier used to reference the node.

\item\textbf{UnaryExpr} represents expressions with a single operand. Attribute \texttt{operand} is operand of the expression.

\item\textbf{NotExpr} represents logical negation expression.

\item\textbf{UnaryMinusExpr} represents unary minus expression.

\item\textbf{BinaryExpr} represents expressions with a two operands.

Attributes \texttt{left} and \texttt{right} represent the first and second operands, respectively.

\item\textbf{OrExpr} represents logical disjunction expression.

\item\textbf{AndExpr} represents logical conjunction expression.

\item\textbf{ComparisonExpr} represents expression that compares two operands.

\item\textbf{IsExpr} represents expression that checks whether the first operand is of the given type, specified by the second operand.

\item\textbf{InExpr} represents expression that checks whether the first operand is present in a list of values, specified by the second operand.

\item\textbf{MatchExpr} represents expression that checks whether the first operand matches a regular expression, specified by the second operand.

\item\textbf{CallExpr} represents expression that invokes a API property or method of the operand. Attribute \texttt{operand} is the operand of the expression. Attribute \texttt{value} is the name of the API property or method that is invoked.

\item\textbf{NodeQueryExpr} represents expression that queries node context. Attribute \texttt{operand} is the node used as a reference point for the query.


\includegraphics[width=0.9\textwidth]{literal}

\item\textbf{IntegerExpr} represents expression containing a integer value.

\item\textbf{StringExpr} represents expression containing a string value.

\item\textbf{BooleanExpr} represents expression containing a boolean value.

\item\textbf{ListExpr} represents expression containing a list value. The elements of the list are of type LiteralExpr.

\item\textbf{NodeTypeExpr} represents expression containing a string value that describes node type.

\item\textbf{PropertyExpr} represents an expression that returns the value of a property of the operand node. Attribute \texttt{operand} represents the node targeted by the expression. Attribute \texttt{value} holds the name of the property that is accessed.

\item\textbf{MethodExpr} represents an expression that returns invokes a method of the operand node. Attribute \texttt{argument} represents argument passed to the invoked method.

\includegraphics[width=0.9\textwidth]{nodequery}

\item\textbf{NextSiblingExpr} represents expression that returns the following sibling of the operand node.

\item\textbf{PreviousSiblingExpr} represents expression that returns the previous sibling of the operand node.

\item\textbf{NodeQueryWithArgExpr} represents expression that queries node context and uses additional constraints for the query. Attribute \texttt{argument} represents the additional constraints used by the query.

\item\textbf{ContainsExpr} represents an expression that checks whether the operand node contains a node that matches given constraints.

\item\textbf{ContainsAllExpr} represents an expression that checks whether the operand node contains nodes that match given constraints.

\item\textbf{CountExpr} represents an expression that counts the number of ancestor nodes of the operand that match a given constraint.

\item\textbf{BeforeExpr} represents an expression that checks whether a given whitespace variation appears before the operand node.

\item\textbf{AfterExpr} represents an expression that checks whether a given whitespace variation appears after the operand node.

\item\textbf{BetweenExpr} represents an expression that checks whether a given whitespace variation appears between the two operand nodes.

\end{description}

\section{Concrete syntax}

This section contains the concrete syntax of the designed DSL. Below are presented the grammar rules accompanied by the mapping to the abstract syntax of the language.


\begin{description}

\item\textbf{stylesheet} represents a style guide.

Abstract Syntax Mapping: ast.ConventionSet.

\begin{snippet}
\begin{verbatim}
stylesheet : context* ;
\end{verbatim}
\end{snippet}

\item\textbf{context} represents a group of logically related conventions. A single style guide can comprise a number of conventions that enforce various constraints, e.g. whitespacing, syntax preference, program style. Such categories refer to different types of nodes and require ignoring certain patterns.  

Abstract Syntax Mapping: ast.Context.

\begin{snippet}
\begin{verbatim}
context : Identifier '{' convention* '}' ;
\end{verbatim}
\end{snippet}

\item\textbf{convention} represents a single rule in the style guide. Conventions are typically expressed by directly stating what is disallowed or describing a condition that if met, requires additional constraints. The former way of expressing conventions are represented by the \texttt{forbid} conventions. The latter approach uses the structure \texttt{find ... require ...}. To break down complex disallowing conventions, the structure \texttt{find ... forbid ...} has been introduced. It aims at improving readability of conventions. 

Abstract Syntax Mapping: ast.Convention.

\begin{snippet}
\begin{verbatim}
convention : 'forbid' pattern 'message' String
           | 'find' pattern ('require'|'forbid') logic_expr 'message' String
           ;
\end{verbatim}
\end{snippet}

\item\textbf{pattern} represents a pattern of nodes and their relations. It can describe a horizontal sequence of sibling nodes and or a vertical pattern of nested nodes. Also, it can describe pairs of elements. 

Abstract Syntax Mapping: ast.Pattern.

\begin{snippet}
\begin{verbatim}
pattern : node_declaration (('in'|'next-to') node_declaration)*
        | fork ('in' node_declaration)*
        ;
fork : '(' node_declaration (',' node_declaration)+ ')' ;
node_declaration : (Identifier '=')? semantic_node ;
\end{verbatim}
\end{snippet}

\item\textbf{semantic\_node} represents a non-whitespace node. It describes the type of the node and its additional constraints. 

Abstract Syntax Mapping: ast.Node.

\begin{snippet}
\begin{verbatim}
semantic_node : node_type ('{' logic_expr '}')? ;
\end{verbatim}
\end{snippet}

\item\textbf{whitespace\_variation} represents a sequence of whitespace nodes. They differ from the rest of the nodes types because the user can specify how many times they need to be consecutively repeated. 

Abstract Syntax Mapping: ast.WhitespaceVariation, ast.WhitespaceNode, ast.Repeater.

\begin{snippet}
\begin{verbatim}
whitespace_variation : whitespace_node ('or' whitespace_node)* ;
whitespace_node : Identifier ('{' repeater '}')? ;
repeater : Integer ',' Integer? | (',')? Integer ;
\end{verbatim}
\end{snippet}

\item\textbf{logic\_expr} represents expressions that perform logic operations and glue arithmetic and type expressions. 

Abstract Syntax Mapping: ast.NotExpr, ast.AndExpr, ast.OrExpr and all arithmetic\_expression and type\_expression mappings.

\begin{snippet}
\begin{verbatim}
logic_expr : '(' logic_expr ')'
           | 'not' logic_expr
           | logic_expr 'and' logic_expr
           | logic_expr 'or' logic_expr
           | type_expr
           | arithmetic_expr
           ;
\end{verbatim}
\end{snippet}

\item\textbf{type\_expr} represents expressions that ensure node type and perform node queries of whitespace nodes. They are located in a separate parser rule because they interpret Identifiers as node type expressions instead of a API calls. 

Abstract Syntax Mapping: ast.IsExpr, ast.BeforeExpr, ast.AfterExpr, ast.BetweenExpr.

\begin{snippet}
\begin{verbatim}
type_expr : arithmetic_expr operator='is' type_=Identifier
          | whitespace_variation ('before' | 'after') type_operand
          | whitespace_variation 'between' type_operand 'and' type_operand
          ;
type_operand : Identifier | semantic_node ;
\end{verbatim}
\end{snippet}

\item\textbf{arithmetic\_expr} represents arithmetic, comparison, set membership and regex expressions. These are located in a separate parser rule because they interpret identifiers as API calls instead of node type expressions.

Abstract Syntax Mapping: ast.UnaryMinus, ast.UnaryPlus, ast.LessThan, ast.LessThanOrEq, ast.GreaterThan, ast.GreaterThanOrEq, ast.Equal, ast.NotEqual, ast.InExpr, ast.MatchExpr, ast.LiteralExpr.

\begin{snippet}
\begin{verbatim}
arithmetic_expr : ('-'|'+') arithmetic_expr
                | arithmetic_expr ('<'|'>'|'<='|'>='|'=='|'!=') arithmetic_expr
                | arithmetic_expr ('in'|'not in'|'match'|'not match') arithmetic_expr
                | call_expression
                | element
                ;
element : Boolean | Integer | String | list_ ;
\end{verbatim}
\end{snippet}

\item\textbf{call\_expr} represents an API call expression and also node query expression.

Abstract Syntax Mapping: ast.CallExpr and ast.NodeQueryExpr.

\begin{snippet}
\begin{verbatim}
call_expr : call_expr '.' call_expr
          | Identifier ('(' (element | semantic_node ) ')')? 
          ;
\end{verbatim}
\end{snippet}

\item\textbf{Boolean:} represents Boolean literal expression. 

Abstract Syntax Mapping: ast.BooleanExpr.

\begin{snippet}
\begin{verbatim}
Boolean : 'true' | 'True' | 'false' | 'False' ;
\end{verbatim}
\end{snippet}

\item\textbf{String:} represents String literal expression.

Abstract Syntax Mapping: ast.StringExpr.

\begin{snippet}
\begin{verbatim}
String : "'" (EscapeSequence | ~['])*? "'" ;
EscapeSequence : "\\" "'" ;
\end{verbatim}
\end{snippet}

\item\textbf{Integer:} represents Integer literal expression. 

Abstract Syntax Mapping: ast.IntegerExpr.

\begin{snippet}
\begin{verbatim}
Integer : (ZeroDigit | NonZeroDigit Digit*) ;
Digit : ZeroDigit | NonZeroDigit ;
NonZeroDigit : [1-9] ;
ZeroDigit : [0] ;
\end{verbatim}
\end{snippet}

\item\textbf{list} and \textbf{list\_element} represent the List literal expression. 

Abstract Syntax Mapping: ast.ListExpr.

\begin{snippet}
\begin{verbatim}
list_ : '[' list_element (',' list_element)* ']' ;
list_element : Integer | String | semantic_node ;
Letter : [a-zA-Z] ;
Identifier : (Letter)(Letter|Digit|'_'|'-')* ;
\end{verbatim}
\end{snippet}

\item\textbf{type\_expression} represents the NodeType literal expression.

Abstract Syntax Mapping: ast.NodeType.

\begin{snippet}
\begin{verbatim}
node_type : '(' node_type ')'
          | 'not' node_type
          | node_type 'and' node_type
          | node_type 'or' node_type
          | Identifier
          ;
\end{verbatim}
\end{snippet}

\end{description}


\section{Validation}

The method chosen for validating the designed domain-specific language is ontological analysis,
since it is a widely-accepted way for evaluating software notations~\cite{opdahl2002ontological,
green2000integrated, moody2009physics, parsons1997using, weber1996analytical}. The particular
approach used for conducting ontological analysis consists of several steps. First, a domain-
specific ontology is designed. Second, the ontology is used as a reference point for the
interpretation and representation mappings. Third, emerged anomalies are analyzed and conclusion
about the quality of the notation is made.

\subsection{Ontology design}

The first stage of validation requires designing a domain-specific ontology. The specific domain of
the developed ontology is limited to detecting violations of CSS code conventions. In other words,
the designed ontology tries to capture only the concepts and their relations, that exist when an
agent searches a CSS program for violations of given set of code conventions.

The designed domain-specific ontology is based on the BWW top-level
ontology~\cite{wand1990ontological}, i.e. it uses the high-level categories of the BWW ontology to
describe the objects, concepts and entities in the specific domain. The rationale behind the
decision to use BWW ontology is that it has been the leading ontology used for ontological
analysis~\cite{moody2009physics}. The main ontological constructs used in the BWW ontology are
listed in section 2.1.

Following is a list with the main concepts discovered in the domain along with their descriptions.
The used BWW concepts are written in \textit{italics} and the domain-specific concepts are written
in \textbf{bold}.

\begin{description}

\item\textit{Class} \textbf{Style Guide} describes the coding practices adopted in the context of a single project, organization, community or language. An individual Style Guide is a composite thing built of Conventions and their relations. Conventions in a Style Guide are interpreted together to form a coherent set of guidelines.

\textit{Property} \textbf{Number of Conventions} indicates the size of the Style Guide.


\item\textit{Class} \textbf{Convention} is a rule that imposes constraints on the CSS program. It is the building block of Style Guides. An individual Convention is a composite thing that consists of a Context.

\textit{Intrinsic Property} \textbf{Description} explains the meaning of the Convention in natural text.

\textit{Mutual Property} \textbf{Exception} is a relation between Conventions in which a given convention serves as an exception of another Convention.

\textit{Mutual Property} \textbf{Allowance} is a relation between Conventions in which a given convention relaxes the constraints of another Convention. 


\item\textit{Class} \textbf{Context} is a description of a Pattern that the Convention forbids. An individual Context is a composite thing that comprises a number of logically related Constraints.

\textit{Property} \textbf{Ignored Constructs} specifies constructs that are disregarded while searching for a Context.


\item\textit{Class} \textbf{Constraint} is a restriction that needs to be fulfilled. Different types of Constraints are represented as kinds.

\textit{Property} \textbf{Subject} indicates the operand on which the Constraint operates. Things that can be a subject are the Type, Textual Representation or CSS-specific knowledge of a Construct.


\item\textit{Kind} \textbf{Comparison Constraint} is a type of Constraint that compares the subject to another value.

\textit{Property} \textbf{Subject} 

\textit{Property} \textbf{Value}


\item\textit{Kind} \textbf{Type Constraint} is a type of Constraint that checks whether the subject is of a given type.

\textit{Property} \textbf{Subject} 

\textit{Property} \textbf{Type}


\item\textit{Kind} \textbf{Textual Form Constraint} is a type of Constraint that imposes restrictions on the textual representation of the subject.

\textit{Property} \textbf{Subject} 

\textit{Property} \textbf{Form}


\item\textit{Kind} \textbf{Set Membership Constraint} is a type of Constraint that requires the subject to be a member of a set.

\textit{Property} \textbf{Subject} 

\textit{Property} \textbf{Set}


\item\textit{Kind} \textbf{Context Constraint} is a type of Constraint that requires the subject to be in a particular context.

\textit{Property} \textbf{Subject} 

\textit{Property} \textbf{Context Description}


\item\textit{Class} \textbf{Violation Log} is the final product of a violations search. An individual Violation Log is a composite thing that contains Violations.

\textit{Property} \textbf{Number of Violations} indicates the size of the Violation Log. 


\item\textit{Class} \textbf{Violation} A Violation occurs when a Pattern that matches the Context of a Convention is found.

\textit{Property} \textbf{Description} explains in natural text what causes the Violation. Typically, the Description is extracted from the Convention that the Violation breaks.

\textit{Property} \textbf{Position in Stylesheet} indicates the location of the Pattern that violates the Convention in the Stylesheet. 


\item\textit{Class} \textbf{Stylesheet} is the CSS code that needs to be checked for compliance with the Style Guide. An instance of Stylesheet is a composite thing that comprises a number of Constructs.


\item\textit{Class} \textbf{Construct} is a part of the Stylesheet. It can refer to nodes in the CSS abstract syntax tree, concrete syntax tree and parse tree. Examples include whitespacing, indentation, comments, colons, delimiters, rulesets, declarations, etc.

\textit{Property} \textbf{Type} identifies the function of a Construct in the program. Examples are strings, attribute values etc.

\textit{Property} \textbf{Textual Representation} is the string of a Construct that appears in the CSS program. Examples are tabs, ``;'', and ``.myclass''

\textit{Property} \textbf{CSS-specific knowledge} encapsulates properties of nodes specific to the CSS domain. For example, a CSS declaration node can possess knowledge whether it is vendor specific or not.

\textit{Mutual Property} \textbf{Relation} is a relation between two Constructs. For example, two Constructs may be adjacent or nested.


\item\textit{Class} \textbf{Pattern} is a particular part of the CSS program that matches the description of a Context. An instance of a Pattern is a composite thing built from one or many Constructs and Relations between them.

\textit{Property} \textbf{Number of Constructs} denotes the size of the Pattern.


\item\textit{Event} \textbf{Search for Violations in Stylesheet} occurs when the developer completes the search for violations in a Stylesheet, a Violation Log is created.

\textit{New State} \textbf{Violation Log} \{ Violations = value \}


\item\textit{Event} \textbf{Context (of Convention) Discovered} occurs when the Context of a convention is discovered, a Violation is recorded in the Violation Log. The state of the Violation contain its description and position in Stylesheet.

\textit{New State} \textbf{Violation} \{ Description = value, Position in Stylesheet = value \}

\end{description}

TODO: include property and event of the Stylesheet!

The descriptions provided in the listing above often state that an instance of a class is a
composite thing that consists of other things. To provide a better understanding of the way
composite things are constructed, the same concepts are also expressed using the Backus-Naur Form
(BNF) notation:

\begin{snippet}
\begin{verbatim}
STYLE_GUIDE     ::= CONVENTIONS
CONVENTIONS     ::= CONVENTIONS CONVENTION | CONVENTION 
CONVETION       ::= CONTEXT
CONTEXT         ::= CONSTRAINTS
CONSTRAINTS     ::= CONSTRAINTS CONSTRAINT | CONSTRAINT
CONSTRAINT      ::= COMPARISON_CONSTRAINT | TYPE_CONSTRAINT | TEXT_CONSTRAINT 
                  | SET_CONSTRAINT | CONTEXT_CONSTRAINT 
VIOLATION_LOG   ::= VIOLATIONS
VIOLATIONS      ::= VIOLATIONS VIOLATION | VIOLATION | EPSILON
STYLESHEET      ::= CONSTRUCTS
CONSTRUCTS      ::= CONSTRUCTS CONSTRUCT | CONSTRUCT
PATTERN         ::= CONSTRUCTS
\end{verbatim}
\end{snippet}

The grammar above illustrates that a Style Guide needs to contain 1 or more Conventions. Similarly,
a Context requires 1 or more Constraints in order to exist. A Violation Log, however, could exist
without any Violations in the cases when a Stylesheet is checked for conformance to a Style Guide
and no violations are discovered. Both Stylesheet and Pattern are defined through 1 or more
Constructs. Note that the concept of Stylesheet does not map to a CSS file, but to the whole CSS
code that needs to be processed, regardless of type of CSS (internal or external). This is why a
Stylesheet requires at least one Construct in order to exist.

While the above grammar presents the composition of things, it does not illustrate how things
interact with each other. To provide a better understanding of the dynamics between things defined
in the ontology, a graph of the system is presented in Figure 5.1.

\begin{figure}[h!]
  \centering
  \caption{Graph of the system}
  \includegraphics[width=0.8\textwidth]{ontology}
\end{figure}

According to the theory, a coupling occurs when the existence of a given thing affects the history
of another thing and, in turn, history is defined as the chronological ordered states that a thing
traverses~\cite{wand1990ontological}. Thus, in the domain-specific ontology a coupling exists
between the Style Guide and the Convention things, because the existence of a Convention alters the
state of the Style Guide. Similarly, a Context changes the state of a Convention and a Constraint
affects the state of a Context.

There are also couplings between Construct, Pattern and Stylesheet things. Both Stylesheet and
Pattern are composed of Constructs, and thus affected by their existence. Since a Pattern is a
specific occurrence of a combination of Constructs, it is also coupled to Stylesheet.

A Violation is coupled to a Violation Log, since the presence of a new a Violation alters the state
of the log. Further, a Violation Log contains information about the violations of a particular Style
Guide that occur in a specific Stylesheet. In this sense, a Violation Log is a function of a Style
Guide and a Stylesheet and it is coupled to both things.

There are two external events that an Actor can initiate: searching for violations and discovering
violations. Both of these events express couplings, because they change the state of the Violation
Log and the Violation, respectively. Note that an Actor can create any of the things that appear in
Figure 5.1. In practice, the Actor can introduce additional Conventions, change the Style Guide,
alter the existing Constructs and rewrite the Stylesheet. However, these events are considered
outside the domain of the designed ontology.

\subsection{Ontological analysis}

The ontological analysis uses the designed domain-specific ontology. It consists of two mappings -
representation and interpretation. As suggested by other authors, the two mappings are expressed in
the form of two tables. 

Typically ontological analysis is used to compare the abstract syntax of the language constructs to
the concepts of an ontology. In the particular case, the language aims at expressing the existing
code conventions. This means that only the part of ontology that describes a Style Guide should be
included. Since the domain of the ontology refers to detecting violations of code conventions, it
does not map to the language constructs only, but to the whole solution that comprises the language
and its interpreter. Thus, the particular approach used to conduct the ontological analysis is
comparing the designed domain-specific ontology to the whole designed system. We believe that such
comparison provides a thorough analysis of the whole solution.

\subsubsection{Representation Mapping} 

In this section the constructs of the domain-specific ontology are mapped to the constructs of the
designed system. Table 5.1. presents the correspondence between the two sets of constructs.

\begin{center}
\begin{longtable}{ | p{17em} | p{23em} | } 
\caption{Representation mapping}\\
\hline
 &  \\
Ontological constructs & Modeling constructs \\
 &  \\
\hline
Style Guide & Convention Set \\ \hline
Number of Conventions of Style Guide & Conventions of Convention Set \\ \hline
Convention & Convention \\ \hline
Description of Convention  & Description of Convention \\ \hline
Exception of Conventions & Exceptions of Convention \\ \hline
Allowance of Conventions & Relaxing Conventions of Convention \\ \hline
Context & Pattern descriptor, Node descriptor, Node Relation \\ \hline
Ignored Constructs & Convention Context \\ \hline
Constraint & Expression \\ \hline
Subject of Constraint & API Call, Literal Expression, Variable Expression, Unary? \\ \hline
Comparison Constraint & Comparison Expression \\ \hline
Type Constraint & Is Expression \\ \hline
Textual Form Constraint & Match Expression \\ \hline
Set Membership Constraint & Set Membership Expression \\ \hline
Context Constraint & Context Query Expression \\ \hline
Violation Log & Violation Log \\ \hline
Number of Violations & Violations of Violation Log \\ \hline
Violation & Violation \\ \hline
Description of Violation & Description of Violation \\ \hline
Position in Stylesheet of Violation & Position of Violation \\ \hline
Stylesheet & Tree \\ \hline
Construct & Node \\ \hline
Type of Construct & Search Categories of Node \\ \hline
Textual Representation of Construct & String of Node \\ \hline
CSS-specific knowledge & API of Node \\ \hline
Relation between Constructs & Node Relation \\ \hline
Pattern & Node, Node Relation \\ \hline
Number of Constructs of Pattern & Node Descriptors of Pattern Descriptor \\ \hline
\end{longtable}
\end{center}

\textbf{Classes}

The majority of the ontological classes have a direct mapping to a construct in the solution. For
example, a Style Guide is mapped to a Convention Set, a Convention is mapped to Convention etc.
However, some of the defined correspondences require further explanation. For example, the ontological concept of a Context is represented by a combination of modeling constructs: Pattern Descriptor, Node Descriptor and Node Relation. In the ontology a Context represents a description of a Pattern. For example, a Context could be ``all color values'' which describes all CSS nodes that express colors, i.e. hexadecimal values, text colors, rgb, rgba, hsl and hsla nodes. That said, a Context could also refer to a particular type of color value - ``hex color values''. In this sense, the Context corresponds to a Pattern Descriptor ...

The notion of Constraint is a particular limitation used in a Context and typically, it is applied
to a single node. The corresponding construct in the system is Expression. Similarly, the specific
kinds of Constraints are mapped to subclasses of the Expression. Specifically, a Comparison
Constraint matches the notion of Comparison Expression. The Type Constraint is expressed through the
Is Expression, which allows verifying the type of a node. The Textual Form Constraint maps to the
Match Expression, which allows using regular expressions on strings. The Set Membership Expression
corresponds to the In Expression that checks whether the subject belongs in a given list of values.
The Context Constraint matches the Node Query Expression, which retrieves node that have a given
relation to the current node.

The concept of Construct corresponds to a Node in the system and a Stylesheet maps to a special kind
of Node that contains the code that needs to be processed. A Pattern is a combination of Nodes. Note
that a Pattern does not correspond to a Node Relation. While relations are used to describe a
Pattern in the concept of a Context, they are not required in a Pattern.

\textbf{Properties}

Similarly to classes, most of the ontological properties map directly to the modeling constructs,
however, some of them need more explanation. The property Subject of Constraint can map to a number
of constructs in the system. In fact, a Subject corresponds to API Call, Literal Expression or
Variable Expression.

The property Ignored Constructs of class Context denotes certain constructs that need to be ignored
while searching for the Context. The property is a consequence of the different level of abstraction
of the expressed conventions. As the Domain Analysis section illustrates, conventions can refer to
the concepts in the abstract syntax tree, concrete syntax tree and parse tree of CSS. Thus, the
Ignored Constructs denote the specific level of abstraction the convention uses. In the system the
notion of Ignored Constructs is represented by a group of conventions called Contexts. In the system
a Context contains conventions that refer to the same level of abstraction and, thus, have the same
Ignored Constructs.

The property Type of class Construct corresponds to the Search Categories of Node, which allow a
single node to be referred using a number of different categories. The property CSS-specific
knowledge of class Construct is mapped to the API of Node. Each Node in the system comprises a
number of properties that are meaningful for its function in the CSS program.

\textbf{Events}

Violations Finder


\subsubsection{Interpretation Mapping}

In this section the constructs of the designed system are mapped to the constructs of the
domain-specific ontology. Table 5.2. presents the correspondence between the two sets of constructs.

\begin{center}
\begin{longtable}{ | p{23em} | p{17em} | } 
\caption{Interpretation mapping}\\
\hline
 &  \\
Modeling constructs & Ontological constructs  \\
 &  \\
\hline

Convention Set & Style Guide \\ \hline
Conventions of Convention Set & Number of Conventions of Style Guide \\ \hline
Convention Context & Ignored Constructs of a Context \\ \hline
Convention & Convention \\ \hline
Description property of Convention & Description of Convention \\ \hline
Exceptions of Convention & Exception of Conventions \\ \hline
Relaxing Conventions of Convention & Allowance of Conventions \\ \hline
Pattern Descriptor, Node Descriptor, Node Relation & Context \\ \hline
Node Descriptors of Pattern Descriptor & Number of Constructs of Pattern \\ \hline
Expression, Logical Expression & Constraint \\ \hline
Comparison Expression & Comparison Constraint \\ \hline
Is Expression & Type Constraint \\ \hline
Match Expression  & Textual Form Constraint \\ \hline
Set Membership Expression & Set Membership Constraint \\ \hline
Context Query Expression & Context Constraint \\ \hline
API Call, Literal Expression, Variable Expression & Constraint Subject \\ \hline
Node & Construct \\ \hline
Search Categories of Node & Type of Construct \\ \hline
String of Node & Textual Representation of Construct \\ \hline
API of Node & CSS-specific knowledge of Construct \\ \hline
Node, Node Relation & Pattern \\ \hline
Tree & Stylesheet \\ \hline
Violations Log & Violations Log \\ \hline
Violations of Violations Log & Number of Violations \\ \hline
Violation & Violation \\ \hline
Description of Violation & Description of Violation \\ \hline
Position of Violation & Position in Stylesheet of Violation \\ \hline
\end{longtable}
\end{center}


\textbf{Abstract Syntax Package}

The majority of modeling constructs that belong the abstract syntax of the language map to a single ontological construct. For example, Convention Set corresponds to the concept of a Style Guide, Convention maps to the concept of Convention, and Expression matches a Constraint.

The WhitespaceVariation is a special type combination of whitespace nodes that can only appear on
as operands of Before, After and Between Expressions. A WhitespaceVariation is semantically a constraint.

Or And and Not Expr do not have a direct ontological concept. However, they are used to glue the
constraints imposed by a single convention. In this sense, they fall in the expression -> Context
mapping.

\textbf{Analysis Package}

Violation and Violations

Violation finder + Expression evaluation and values belong to

Type checker 

\textbf{CSS Package}

Node 

Stylesheet

\subsection{Ontological Evaluation of the System}

The representation and interpretation mappings between the ontology and the system allow discovery
of one of the four discrepancies: construct redundancy, construct overload, construct excess and
construct deficit.

\subsubsection{Redundant Constructs} 

Construct redundancy is a type of anomaly in which more than one modeling constructs can represent a
single ontological construct. Candidate redundant constructs are the CallExpression,
LiteralExpression, VariableExpression and UnaryExpression, since they all appear to map to the same
ontological construct - Constraint. However, none of these constructs, taken individually, is
capable of representing the concept of Constraint. It is their combination that expresses the
concept. For this reason, the candidate constructs are not considered redundant. In fact, a number
of researchers have compared a construct to a combination of constructs~\cite{gehlert2007toward}.

\subsubsection{Construct Overload}

Construct overload emerges when a single modeling construct can represent a number of ontological
constructs. No candidates for construct overload have been found.

\subsubsection{Construct Excess}

Construct excess is a discrepancy in which a modeling construct does not have a mapping ontological construct. The system contains a number of classes and packages that do not have a corresponding ontological concepts, e.g. Type Checker. However, the class is used to ensure the correctness of the Style Guide. In this sense, it has a supporting function that contributes to an ontological concept.

\subsubsection{Construct Deficit}

Construct deficit appears when an ontological construct does not have a corresponding modeling
structure. A candidate for such discrepancy is the property Checked of class Stylesheet as it
appears without a matching construct in the system. However, maintaining the status of a Stylesheet
is considered outside the scope of the system. Such functionality can be added based on whether the
IDE or text editor expose such knowledge. That said, the structure remains in the environment of the
system and thus, the candidate is not considered a deficit.

Having the above consideration in mind, we believe the ontological analysis provides sufficient evidence to consider the designed system both ontologically clear and complete.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Conclusion}

This work makes several contributions. 1) 2) It contains a summary of existing
CSS coding conventions. 3) It designs a domain specific language that expresses
conventions and its interpreter to detect violations automatically.

{%\tiny
\bibliographystyle{alphaurl}
\bibliography{thesis}
}

\end{document}
